package cmd

import (
	"bytes"
	"fmt"
	"os"
	"path/filepath"
	"reflect"
	"text/template"
	"time"

	"dario.cat/mergo"
	"github.com/alecthomas/kong"
	"github.com/rs/zerolog"
	"gopkg.in/yaml.v3"
)

// CLI defines the command-line interface structure using kong.
type CLI struct {
	// Config is the path to one or more WHAM configuration files. Later files override earlier ones.
	Config []string `help:"WHAM config file(s). Later files override earlier ones." default:"settings.yaml" short:"c"`
	// Debug enables verbose debug logging.
	Debug bool `help:"Enable debug logging" short:"d"`
	// Output format for commands that support it.
	Output string `help:"Output format (table, json, yaml)." short:"o" default:"table"`

	// Canonical commands (object-verb)
	Step      StepCmd   `cmd:"" help:"Manage and execute workflow steps."`
	State     StateCmd  `cmd:"" help:"Manage the state of steps."`
	DAG       DAGCmd    `cmd:"" help:"Interact with the workflow's DAG."`
	ConfigCmd ConfigCmd `cmd:"" help:"Inspect the configuration." name:"config"`

	// Shortcuts for primary actions
	Run      RunStepCmd      `cmd:"" help:"Run a step or all steps. Use --force to ignore state." name:"run"`
	Validate ValidateStepCmd `cmd:"" help:"Validate a step or all steps (shortcut for 'step validate')." name:"validate"`
	Get      GetStepCmd      `cmd:"" help:"Get a step's configuration (shortcut for 'step get')." name:"get"`
	Describe DescribeStepCmd `cmd:"" help:"Describe a step's configuration and state (shortcut for 'step describe')." name:"describe"`
	Version  VersionCmd      `cmd:"" help:"Show WHAM! version information."`
}

// CLI Methods

// Parse initializes and parses the command-line arguments using kong.
// It centralizes the CLI definition and configuration.
func Parse(cli *CLI) *kong.Context {
	return kong.Parse(cli,
		kong.Name("wham"),
		kong.Description("WHAM! - A smart and stateful task runner for local workflows."),
		kong.UsageOnError(),
		kong.ConfigureHelp(kong.HelpOptions{
			Compact: true,
		}),
	)
}

// WhamSettings defines global parameters for the workflow.
type WhamSettings struct {
	// DataDir is the directory for scripts to read/write data files.
	DataDir string `yaml:"data_dir" json:"data_dir"`
	// MetadataDir is the directory where WHAM stores its state files.
	MetadataDir string `yaml:"metadata_dir" json:"metadata_dir"`
	// MetadataPrefix is the prefix for WHAM state file names (e.g., "wham_").
	MetadataPrefix string `yaml:"metadata_prefix" json:"metadata_prefix"`
	// MetadataSuffix is the suffix for WHAM state file names (e.g., ".state").
	MetadataSuffix string `yaml:"metadata_suffix" json:"metadata_suffix"`
	// MetadataAddDepth determines whether to include the step's DAG depth in the state filename.
	MetadataAddDepth bool `yaml:"metadata_add_depth" json:"metadata_add_depth"`
	// MetadataDepthPadding is the number of digits for zero-padding the depth in filenames.
	MetadataDepthPadding int `yaml:"metadata_depth_padding" json:"metadata_depth_padding"`
	// sharedArgs are command-line parameters to be passed to every step script.
	SharedArgs []string `yaml:"shared_args" json:"shared_args"`
}

// Step defines a single executable unit in the workflow.
type Step struct {
	// Name is the unique identifier for the step.
	Name string `yaml:"name" json:"name"`
	// Command is the path to the executable script for this step. Can be relative to the config file.
	Command []string `yaml:"command" json:"command"`
	// Args are the command-line parameters specific to this step.
	Args []string `yaml:"args" json:"args"`
	// EnvVars is a list of environment variables to be set for the script's execution.
	EnvVars map[string]string `yaml:"env_vars" json:"env_vars"`
	// Retries is the number of times to retry a failed script. Defaults to 0 (no retries).
	Retries int `yaml:"retries" json:"retries"`
	// RetryDelay is the duration to wait between retries (e.g., "5s", "1m").
	RetryDelay time.Duration `yaml:"retry_delay" json:"retry_delay"`
	// CanFail, if true, allows the workflow to continue even if this step fails.
	CanFail bool `yaml:"can_fail" json:"can_fail"`
	// IsStateful determines the step's behavior. A stateful step's state is determined
	// by an external state file it generates. A stateless step's state is derived
	// from its predecessors.
	IsStateful bool `yaml:"is_stateful" json:"is_stateful"`
	// StateFile is the name of the file generated by a stateful step, located in MetadataDir.
	StateFile string `yaml:"state_file" json:"state_file"`
	// RunIdVar is the variable name inside the StateFile that holds the run ID.
	RunIdVar string `yaml:"run_id_var" json:"run_id_var"`
	// PreviousSteps is a list of step names that must complete before this step can run.
	PreviousSteps []string `yaml:"previous_steps" json:"previous_steps"`
	// WorkDir, if specified, sets the working directory for the script's execution.
	// The path can be absolute or relative to the configuration file's directory.
	WorkDir string `yaml:"work_dir,omitempty" json:"work_dir,omitempty"`
	// Image specifies the container image to be used for this step in an orchestrated environment.
	Image string `yaml:"image,omitempty" json:"image,omitempty"`
}

// StepState represents the persisted state of a WHAM step execution.
type StepState struct {
	// RunID is the unique identifier for a specific execution state of the step.
	RunID string `json:"run_id" yaml:"run_id"`
	// RunDate is the timestamp of when the state was recorded.
	RunDate time.Time `json:"run_date" yaml:"run_date"`
	// RunAction is the outcome of the execution ("run", "skipped", or "failed").
	RunAction string `json:"run_action" yaml:"run_action"`
	// Elapsed is the duration of the step's execution.
	Elapsed time.Duration `json:"elapsed" yaml:"elapsed"`
}

// Config holds the entire application configuration, including settings and steps.
type Config struct {
	WhamSettings WhamSettings `yaml:"wham_settings" json:"wham_settings"`
	WhamSteps    []Step       `yaml:"wham_steps" json:"wham_steps"`
	// ConfigDir stores the absolute path of the directory containing the config file.
	// This is resolved at load time and used as a base for all other relative paths.
	ConfigDir string `json:"-"` // Exclude from JSON marshaling for tests
}

// WHAM is the main engine for managing and executing workflow steps.
type WHAM struct {
	config *Config
	logger zerolog.Logger
	// stepsMap provides O(1) access to step definitions by their name.
	stepsMap map[string]*Step
	// stepDepths stores the calculated depth in the DAG for each step.
	stepDepths map[string]int
}

// WHAM methods

// Context holds shared data for CLI commands, like the WHAM instance and the logger.
type Context struct {
	// WHAM is the active WHAM engine instance.
	WHAM *WHAM
	// Logger is the configured logger instance.
	Logger zerolog.Logger
	// OutputFormat holds the global output format for the current command execution.
	OutputFormat string
}

// NewWHAM creates and initializes a new WHAM instance.
// It resolves the data and metadata directories to absolute paths and calculates
// the depths for all steps. It returns an error if the configuration is invalid.
func NewWHAM(config *Config, logger zerolog.Logger) (*WHAM, error) {
	stepsMap := make(map[string]*Step)
	for i := range config.WhamSteps {
		step := &config.WhamSteps[i]
		if _, exists := stepsMap[step.Name]; exists {
			return nil, fmt.Errorf("duplicate step name found in configuration: '%s'", step.Name)
		}
		stepsMap[step.Name] = step

		// Validate the semantic correctness of the step's definition.
		if err := validateStepDefinition(step); err != nil {
			return nil, fmt.Errorf("invalid configuration for step '%s': %w", step.Name, err)
		}
	}

	wham := &WHAM{
		config:     config,
		logger:     logger,
		stepsMap:   stepsMap,
		stepDepths: make(map[string]int),
	}
	wham.calculateStepDepths() // Calculate depths on initialization
	return wham, nil
}

// validateStepDefinition checks for common semantic errors in a step's configuration.
func validateStepDefinition(step *Step) error {
	if step.Name == "" {
		return fmt.Errorf("step name cannot be empty")
	}
	if len(step.Command) == 0 {
		return fmt.Errorf("command cannot be empty")
	}
	if step.IsStateful {
		if step.StateFile == "" {
			return fmt.Errorf("stateful steps must have a 'state_file' defined")
		}
		if step.RunIdVar == "" {
			return fmt.Errorf("stateful steps must have a 'run_id_var' defined")
		}
	}
	if step.Retries < 0 {
		return fmt.Errorf("retries cannot be negative")
	}
	if step.RetryDelay < 0 {
		return fmt.Errorf("retry_delay cannot be negative")
	}
	return nil
}

// Config returns a pointer to the internal Config struct.
func (w *WHAM) Config() *Config {
	return w.config
}

// LoadConfig reads, parses, and prepares the WHAM configuration from a YAML file.
//
// It performs three main actions:
//  1. Reads the content of the file specified by `configPath`.
//  2. Unmarshals the YAML content into a `Config` struct.
//  3. Resolves the absolute path of the directory containing the configuration file
//     and stores it in the `ConfigDir` field. This is critical for correctly
//     resolving relative paths for scripts and data/metadata directories later on.
//
// Returns a pointer to the fully populated `Config` object or an error if any
// step fails. It now uses the 'mergo' library for robust deep merging.
func LoadConfig(configPaths ...string) (*Config, error) {
	if len(configPaths) == 0 {
		return nil, fmt.Errorf("no configuration file provided")
	}

	// Load the base configuration file first.
	baseData, err := os.ReadFile(configPaths[0])
	if err != nil {
		return nil, fmt.Errorf("failed to read base config file '%s': %w", configPaths[0], err)
	}
	var finalConfig Config
	if err := yaml.Unmarshal(baseData, &finalConfig); err != nil {
		return nil, fmt.Errorf("failed to parse YAML from base config '%s': %w", configPaths[0], err)
	}

	// Load and merge subsequent override files.
	for _, path := range configPaths[1:] {
		overrideData, err := os.ReadFile(path)
		if err != nil {
			return nil, fmt.Errorf("failed to read override config file '%s': %w", path, err)
		}
		var overrideConfig Config
		if err := yaml.Unmarshal(overrideData, &overrideConfig); err != nil {
			return nil, fmt.Errorf("failed to parse YAML from override config '%s': %w", path, err)
		}

		// Use mergo to deep merge the override config into the final config.
		// We use a custom transformer to intelligently merge the wham_steps slice.
		if err := mergo.Merge(&finalConfig, overrideConfig, mergo.WithOverride, mergo.WithTransformers(stepSliceTransformer{})); err != nil {
			return nil, fmt.Errorf("failed to merge configuration from '%s': %w", path, err)
		}
	}

	config := finalConfig // Use a shorter name for the final, resolved config.

	// Resolve and store the absolute path of the configuration file's directory.
	// This path is used as the base for all other relative paths in the config.
	// We use the directory of the *first* config file as the base anchor.
	configDir, err := filepath.Abs(filepath.Dir(configPaths[0]))
	if err != nil {
		return nil, fmt.Errorf("failed to get absolute directory of config file '%s': %w", configPaths[0], err)
	}
	config.ConfigDir = configDir

	// IMPORTANT: Make the data_dir and metadata_dir paths absolute
	// using ConfigDir as the base, which is the directory of the settings.yaml file.
	if !filepath.IsAbs(config.WhamSettings.DataDir) {
		config.WhamSettings.DataDir = filepath.Join(config.ConfigDir, config.WhamSettings.DataDir)
	}
	config.WhamSettings.DataDir = filepath.Clean(config.WhamSettings.DataDir)

	if !filepath.IsAbs(config.WhamSettings.MetadataDir) {
		config.WhamSettings.MetadataDir = filepath.Join(config.ConfigDir, config.WhamSettings.MetadataDir)
	}
	config.WhamSettings.MetadataDir = filepath.Clean(config.WhamSettings.MetadataDir)

	return &config, nil
}

// stepSliceTransformer is a custom transformer for the 'mergo' library.
// It teaches mergo how to intelligently merge slices of `cmd.Step` based on the `Name` field.
type stepSliceTransformer struct{}

// Transformer defines the custom merge logic for the `[]Step` type.
func (t stepSliceTransformer) Transformer(typ reflect.Type) func(dst, src reflect.Value) error {
	if typ == reflect.TypeOf([]Step{}) {
		return func(dst, src reflect.Value) error {
			// Convert reflect.Value to the actual slice type.
			baseSteps := dst.Interface().([]Step)
			overrideSteps := src.Interface().([]Step)

			// Create a map of override steps for efficient lookup.
			overrideMap := make(map[string]Step)
			for _, step := range overrideSteps {
				overrideMap[step.Name] = step
			}

			// Merge existing steps and preserve order.
			var finalSteps []Step
			for _, baseStep := range baseSteps {
				if overrideStep, exists := overrideMap[baseStep.Name]; exists {
					// If an override exists for a base step, merge it.
					if err := mergo.Merge(&baseStep, overrideStep, mergo.WithOverride); err != nil {
						return err
					}
					// Then remove it from the map so only new steps remain.
					delete(overrideMap, baseStep.Name) // Mark as processed.
				}
				finalSteps = append(finalSteps, baseStep)
			}

			// Append any new steps from the override file.
			for _, step := range overrideSteps {
				// The map now only contains steps that were not in the base config.
				if _, isNew := overrideMap[step.Name]; isNew {
					finalSteps = append(finalSteps, step)
				}
			}

			// Set the destination slice to the newly merged slice.
			dst.Set(reflect.ValueOf(finalSteps))
			return nil
		}
	}
	return nil
}

// processTemplateString executes a Go template on a given string using runtime context.
func (w *WHAM) processTemplateString(tplStr string, context TemplateContext) (string, error) {
	if tplStr == "" {
		return "", nil
	}

	funcMap := template.FuncMap{
		// getenv retrieves the value of the environment variable named by the key.
		// It can optionally take a second argument as a default value.
		// Usage: {{ getenv "VAR_NAME" }} or {{ getenv "VAR_NAME" "default_value" }}
		"getenv": func(args ...string) (string, error) {
			if len(args) < 1 || len(args) > 2 {
				return "", fmt.Errorf("getenv expects 1 or 2 arguments, but got %d", len(args))
			}
			key := args[0]
			value, ok := os.LookupEnv(key)
			if ok {
				return value, nil
			}
			if len(args) == 2 {
				return args[1], nil // Return the default value
			}
			return "", nil // Return empty string if no default is provided
		},
		// require_env retrieves the value of the environment variable named by the key.
		// It returns an error if the variable is not present or is empty, causing the
		// step to fail. This is useful for mandatory variables like secrets.
		"require_env": func(key string) (string, error) {
			value, ok := os.LookupEnv(key)
			if !ok || value == "" {
				return "", fmt.Errorf("required environment variable '%s' is not set or is empty", key)
			}
			return value, nil
		},
	}

	tmpl, err := template.New("runtime_param").Funcs(funcMap).Parse(tplStr)
	if err != nil {
		return "", fmt.Errorf("failed to parse parameter template: %w", err)
	}

	var processed bytes.Buffer
	if err := tmpl.Execute(&processed, context); err != nil {
		return "", fmt.Errorf("failed to execute parameter template: %w", err)
	}
	return processed.String(), nil
}
